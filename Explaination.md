# 1.Choice of base image on which to build the container 
- For both container I decided to use the base_image: [node:14-apline] due to its lightweight Alpine Linux base, which offers improved efficiency, security, and resource utilization for Docker containers running Node.js applications.

# 2.Dockerfile Directives for Building Images and Running Containers

 - In this project, Dockerfile directives are used to define the build process for creating Docker images and to specify the runtime behavior of the containers. Two Dockerfiles are utilized, one for building the client image and another for the backend image.

  - These Dockerfiles consist of a series of directives that are executed in sequence during the build process:

FROM: Specifies the base image to use for building the Docker image. In this case, node:14-alpine is used, which provides a lightweight Node.js runtime environment based on Alpine Linux.

WORKDIR: Sets the working directory inside the container where subsequent commands will be executed.

COPY: Copies files and directories from the host machine into the container. This is used to bring in the application code and any necessary configuration files.

RUN: Executes shell commands inside the container during the build process. In these Dockerfiles, it's used to install dependencies using npm.

EXPOSE: Exposes specific ports from the container to the host machine, allowing communication between the containerized application and the outside world.

CMD: Specifies the default command to run when the container starts. This command is executed when the container is launched, defining the runtime behavior of the containerized application.

# 3.Docker Networking(port allocation & bridge newtork impelementation)

## Port allocation 
 - it's specified under each service of the docker compose file.For example the client service looks like this: 
    ports:
      - "3001:3001"
  - This indicates that port 3001 on the host machine is mapped to port 3001 inside the container for the client service.Port allocation allows external communication with the Docker containers. 

## Bridge network implementation
  - Within the docker-compose file The networks section defines a custom bridge network named yolo_net:
    networks:
        yolo_net:
          driver:bridge
  
  - Bridge networking creates a private internal network that allows containers within the same network to communicate with each other.So the client & backend service are connected to this network 

# 4.Docker compose-volume definition & usage(where necessary)
## Definition
   - Docker volumes provide a way to persist data generated by and used by Docker containers.
   - Volumes are defined in the docker-compose.yml file under the volumes section.
   - For example,in the client service definition: 
        volumes:
        - "./client:/var/www/client"
# 5.Git workflow used to achieve the task 
## Workflow Steps:
- Cloning the Repository: clone the project repository to local machines using the git clone command.

- Making Changes: make changes to files locally, including implementing new features, fixing bugs, or making enhancements.

- Committing Changes: After making changes, commit them directly to the master branch using the git add and git commit commands.

- Pushing Changes: Once changes are committed locally, push them to the remote repository using the git push command.


# 6.Successfull running of application & if not debugging applied 
## Debbuging applied
- When running `sudo docker-compose ps` to check the services that are running I found my Client service wasn't running 
-Tried checking the the React Application logs to troubleshoot this issue but came across this error:
 `ERROR: No such service: react_app` & yet it exists.The container has been created but unfortunately it's unable to run
 - `sudo docker-compose logs client`-used this command to check the logs of the client service.The error message indicates that npm is unable to find the package.json file in the /client/app directory within your container. 


# 7.Inclusion of Docker image tag naming standards for ease of identification of images and containers 
## Image tagging
  - Each service specifies an image tag using the image keyword. For example in the compose file the client service:
          image: arodi21/client_side:v1.1.1
  
  - Image tagging allows for versioning of Docker images, ensuring consistency and reproducibility across    deployments.Also by specifying version tags (v1.1.1), it becomes easy to track and manage changes to the images over time.

# 8.Screenshot of deployed image on DockerHub-clearly show the version of the image 
 
 ![Docker Client Image](<Screenshot from 2024-05-01 21-29-25.png>)

 ![Docker Server Image](<Screenshot from 2024-05-01 21-32-35.png>)


# 9. Screenshot of the eCommerce application

![alt text](<Screenshot from 2024-06-18 23-08-15.png>)

